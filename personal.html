<html>
<head>
	<style>
		body {
			margin: 0;
		}

		canvas {
			width: 100%;
			height: 100%
		}
	</style>
</head>
<body>
	<script src="three.min.js"></script>
	<script src="labyrinth.js"></script>
	<script src="GLTFLoader.js"></script>
	<script src="OBJLoader.js"></script>
	<script src="MTLLoader.js" type="module"></script>

	<script>
		var renderer = new THREE.WebGLRenderer({ antialias: true });
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.setAnimationLoop(drawFrame);
		renderer.shadowMap.enabled = true;
		renderer.shadowMap.type = THREE.PCFSoftShadowMap;
		document.body.appendChild(renderer.domElement);

		document.body.addEventListener('keydown', onKeyDown);
		document.body.addEventListener('keyup', onKeyUp);

		var scene = new THREE.Scene();

		var aspect = window.innerWidth / window.innerHeight;
		var camera = new THREE.PerspectiveCamera(30, aspect);
		camera.position.set(30, 15, 30);
		camera.lookAt(scene.position);

		var plane = new THREE.Mesh(new THREE.BoxGeometry(20, 0.1, 21), new THREE.MeshPhongMaterial({ color: 'gray' }));
		plane.position.set(0, -0.4, 0);
		scene.add(plane);

		var goal = new THREE.Mesh(new THREE.SphereGeometry(1, 32, 32), new THREE.MeshPhongMaterial({ color: 'white' }));
		goal.position.set(2 * dW - 3, 1.5, 2 * dH);
		scene.add(goal);

		generateLabyrinth();


		var block = new THREE.BoxGeometry(1, 1, 1);
		var labyrinth = new THREE.Group();
		var labyrinthMaterial = new THREE.MeshPhongMaterial({ color: 'gray', shininess: 10 });

		var border = new THREE.Group();
		var borderMaterial = new THREE.MeshPhongMaterial({ color: 'brown' });


		for (var x = 0; x < 2 * dW + 1; x++)
			for (var y = 0; y < 2 * dH + 2; y++)
				if (isWall(x, y)) {

					var wall = new THREE.Mesh(block, labyrinthMaterial);
					var h = 0.4 + 1.2 * Math.random();
					wall.scale.set(1, h, 1);
					wall.position.set(x, h / 2 - 0.5, y);
					labyrinth.add(wall);

					if (h < 0.7) {
						var wall = wall.clone();
						wall.scale.set(1, 0.2, 1);
						wall.position.set(x, 0.5, y);
						labyrinth.add(wall);
					}

					var wall = new THREE.Mesh(block, borderMaterial);
					wall.scale.set(1.05, 1, 1.05);
					wall.position.set(x, -0.8, y);
					border.add(wall);
				}
		scene.add(labyrinth, border);

		var x = 1;
		var z = 2;
		var dir = 0;

		var turnLeft = false;
		var turnRight = false;
		var goForward = false;

		var cos = Math.cos(dir);
		var sin = Math.sin(dir);




		// 개인 장소의 불빛
		light = new THREE.DirectionalLight("white", 1);  // 방향성 조명 추가
		light.position.set(200, 200, 200);  // 조명 위치 설정
		light.castShadow = true;
		light.target.position.set(0, -1, 0);
		scene.add(light.target);
		scene.add(light);

		var pointLight = new THREE.PointLight(0xffa500, 2, 10);  // 주황빛, 강도, 거리
		pointLight.position.set(196, 0.5, 213.5);
		pointLight.castShadow = true;
		scene.add(pointLight);

		var pointLight = new THREE.PointLight(0xffa500, 2, 10);  // 주황빛, 강도, 거리
		pointLight.position.set(196, 0.5, 204.5);
		pointLight.castShadow = true;
		scene.add(pointLight);

		var pointLight = new THREE.PointLight(0xffa500, 2, 10);  // 주황빛, 강도, 거리
		pointLight.position.set(204, 0.5, 204.5);
		pointLight.castShadow = true;
		scene.add(pointLight);

		var pointLight = new THREE.PointLight(0xffa500, 2, 10);  // 주황빛, 강도, 거리
		pointLight.position.set(204, 0.5, 213.5);
		pointLight.castShadow = true;
		scene.add(pointLight);

		//개인 공간 꾸미는 곳
		const textureLoader = new THREE.TextureLoader();
		const texture = textureLoader.load('model/sea/textures/material_4_baseColor.jpeg'); // 텍스처 파일 경로 지정

		// 구체 생성
		const sphereGeometry = new THREE.SphereGeometry(20, 32, 32); // 구체의 반지름을 10으로 설정
		const sphereMaterial = new THREE.MeshPhongMaterial({
			map: texture,  // 텍스처를 구체 재질에 추가
			side: THREE.BackSide
		});

		// 텍스처가 적용된 구체 메시 생성
		const texturedSphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
		texturedSphere.position.set(202, 1, 208);  // 구체 위치 설정



		var plane = new THREE.Mesh(new THREE.BoxGeometry(10, 0.1, 10), new THREE.MeshPhongMaterial({ color: 'gray' }));
		plane.position.set(200.5, -0.4, 209.5);
		plane.castShadow = true;
		plane.receiveShadow = true;
		scene.add(plane);

		var plane = new THREE.Mesh(new THREE.BoxGeometry(10, 1, 0.1), new THREE.MeshPhongMaterial({ color: 'gray' }));
		plane.position.set(200.5, -0.4, 204.5);
		plane.receiveShadow = true;
		plane.castShadow = true;
		scene.add(plane);

		var plane = new THREE.Mesh(new THREE.BoxGeometry(10, 1, 0.1), new THREE.MeshPhongMaterial({ color: 'gray' }));
		plane.position.set(200.5, -0.4, 214.5);
		plane.receiveShadow = true;
		plane.castShadow = true;
		scene.add(plane);

		var plane = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1, 10), new THREE.MeshPhongMaterial({ color: 'gray' }));
		plane.position.set(205.5, -0.4, 209.5);
		plane.receiveShadow = true;
		plane.castShadow = true;
		scene.add(plane);

		var plane = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1, 10), new THREE.MeshPhongMaterial({ color: 'gray' }));
		plane.position.set(195.5, -0.4, 209.5);
		plane.receiveShadow = true;
		plane.castShadow = true;
		scene.add(plane);

		// Add walls for x space (400, 400)
		var planeX1 = new THREE.Mesh(new THREE.BoxGeometry(10, 1, 0.1), new THREE.MeshPhongMaterial({ color: 'gray' }));
		planeX1.position.set(400.5, -0.4, 404.5);
		planeX1.receiveShadow = true;
		planeX1.castShadow = true;
		scene.add(planeX1);

		var planeX2 = new THREE.Mesh(new THREE.BoxGeometry(10, 1, 0.1), new THREE.MeshPhongMaterial({ color: 'gray' }));
		planeX2.position.set(400.5, -0.4, 414.5);
		planeX2.receiveShadow = true;
		planeX2.castShadow = true;
		scene.add(planeX2);

		var planeX3 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1, 10), new THREE.MeshPhongMaterial({ color: 'gray' }));
		planeX3.position.set(405.5, -0.4, 409.5);
		planeX3.receiveShadow = true;
		planeX3.castShadow = true;
		scene.add(planeX3);

		var planeX4 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1, 10), new THREE.MeshPhongMaterial({ color: 'gray' }));
		planeX4.position.set(395.5, -0.4, 409.5);
		planeX4.receiveShadow = true;
		planeX4.castShadow = true;
		scene.add(planeX4);

		// Add walls for c space (600, 600)
		var planeC1 = new THREE.Mesh(new THREE.BoxGeometry(10, 1, 0.1), new THREE.MeshPhongMaterial({ color: 'gray' }));
		planeC1.position.set(600.5, -0.4, 604.5);
		planeC1.receiveShadow = true;
		planeC1.castShadow = true;
		scene.add(planeC1);

		var planeC2 = new THREE.Mesh(new THREE.BoxGeometry(10, 1, 0.1), new THREE.MeshPhongMaterial({ color: 'gray' }));
		planeC2.position.set(600.5, -0.4, 614.5);
		planeC2.receiveShadow = true;
		planeC2.castShadow = true;
		scene.add(planeC2);

		var planeC3 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1, 10), new THREE.MeshPhongMaterial({ color: 'gray' }));
		planeC3.position.set(605.5, -0.4, 609.5);
		planeC3.receiveShadow = true;
		planeC3.castShadow = true;
		scene.add(planeC3);

		var planeC4 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1, 10), new THREE.MeshPhongMaterial({ color: 'gray' }));
		planeC4.position.set(595.5, -0.4, 609.5);
		planeC4.receiveShadow = true;
		planeC4.castShadow = true;
		scene.add(planeC4);


		// GLTF 파일 로드
		const loader = new THREE.GLTFLoader();
		loader.load('model/jar/scene.gltf', function (gltf) {
			model = gltf.scene.children[0];
			model.castShadow = true;        // 모델이 그림자를 투사하도록 설정
			model.receiveShadow = true;
			model.scale.set(0.06, 0.06, 0.06);

			model.position.x = 205;
			model.position.y = 0;
			model.position.z = 214.5;
			scene.add(gltf.scene);
		}, undefined, function (error) {
			console.error(error);
		});

		///////////////////////////////////////////////////////////

		// 개인 장소의 불빛 - (400, 400)
		var light1 = new THREE.DirectionalLight("white", 1);
		light1.position.set(400, 400, 400);
		light1.castShadow = true;
		light1.target.position.set(0, -1, 0);
		scene.add(light1.target);
		scene.add(light1);

		var pointLight1_1 = new THREE.PointLight(0xffa500, 2, 10);
		pointLight1_1.position.set(396, 0.5, 413.5);
		pointLight1_1.castShadow = true;
		scene.add(pointLight1_1);

		var pointLight1_2 = new THREE.PointLight(0xffa500, 2, 10);
		pointLight1_2.position.set(396, 0.5, 404.5);
		pointLight1_2.castShadow = true;
		scene.add(pointLight1_2);

		var pointLight1_3 = new THREE.PointLight(0xffa500, 2, 10);
		pointLight1_3.position.set(404, 0.5, 404.5);
		pointLight1_3.castShadow = true;
		scene.add(pointLight1_3);

		var pointLight1_4 = new THREE.PointLight(0xffa500, 2, 10);
		pointLight1_4.position.set(404, 0.5, 413.5);
		pointLight1_4.castShadow = true;
		scene.add(pointLight1_4);

		var plane1 = new THREE.Mesh(new THREE.BoxGeometry(10, 0.1, 10), new THREE.MeshPhongMaterial({ color: 'gray' }));
		plane1.position.set(400.5, -0.4, 409.5);
		plane1.castShadow = true;
		plane1.receiveShadow = true;
		scene.add(plane1);

		// 텍스처가 적용된 구체 - (400, 400)
		var texturedSphere1 = new THREE.Mesh(sphereGeometry, sphereMaterial);
		texturedSphere1.position.set(402, 1, 408);
		scene.add(texturedSphere1);

		// 모델 추가
		loader.load('model/jar/scene.gltf', function (gltf) {
			model = gltf.scene.children[0];
			model.castShadow = true;
			model.receiveShadow = true;
			model.scale.set(0.06, 0.06, 0.06);
			model.position.set(405, 0, 414.5);
			scene.add(gltf.scene);
		}, undefined, function (error) {
			console.error(error);
		});

		// 개인 장소의 불빛 - (600, 600)
		var light2 = new THREE.DirectionalLight("white", 1);
		light2.position.set(600, 600, 600);
		light2.castShadow = true;
		light2.target.position.set(0, -1, 0);
		scene.add(light2.target);
		scene.add(light2);

		var pointLight2_1 = new THREE.PointLight(0xffa500, 2, 10);
		pointLight2_1.position.set(596, 0.5, 613.5);
		pointLight2_1.castShadow = true;
		scene.add(pointLight2_1);

		var pointLight2_2 = new THREE.PointLight(0xffa500, 2, 10);
		pointLight2_2.position.set(596, 0.5, 604.5);
		pointLight2_2.castShadow = true;
		scene.add(pointLight2_2);

		var pointLight2_3 = new THREE.PointLight(0xffa500, 2, 10);
		pointLight2_3.position.set(604, 0.5, 604.5);
		pointLight2_3.castShadow = true;
		scene.add(pointLight2_3);

		var pointLight2_4 = new THREE.PointLight(0xffa500, 2, 10);
		pointLight2_4.position.set(604, 0.5, 613.5);
		pointLight2_4.castShadow = true;
		scene.add(pointLight2_4);

		var plane2 = new THREE.Mesh(new THREE.BoxGeometry(10, 0.1, 10), new THREE.MeshPhongMaterial({ color: 'gray' }));
		plane2.position.set(600.5, -0.4, 609.5);
		plane2.castShadow = true;
		plane2.receiveShadow = true;
		scene.add(plane2);

		// 텍스처가 적용된 구체 - (600, 600)
		var texturedSphere2 = new THREE.Mesh(sphereGeometry, sphereMaterial);
		texturedSphere2.position.set(602, 1, 608);
		scene.add(texturedSphere2);

		// 모델 추가
		loader.load('model/jar/scene.gltf', function (gltf) {
			model = gltf.scene.children[0];
			model.castShadow = true;
			model.receiveShadow = true;
			model.scale.set(0.06, 0.06, 0.06);
			model.position.set(605, 0, 614.5);
			scene.add(gltf.scene);
		}, undefined, function (error) {
			console.error(error);
		});


		///////////////////////////////////////////////////////////


		// z = (200, 200)
		loader.load('model/jar/scene.gltf', function (gltf) {
			model = gltf.scene.children[0];
			model.castShadow = true;
			model.receiveShadow = true;
			model.scale.set(0.06, 0.06, 0.06);
			model.position.set(201.5, -0.35, 207);
			scene.add(gltf.scene);
		}, undefined, function (error) {
			console.error(error);
		});

		// x = (400, 400)
		loader.load('model/jar/scene.gltf', function (gltf) {
			model = gltf.scene.children[0];
			model.castShadow = true;
			model.receiveShadow = true;
			model.scale.set(0.06, 0.06, 0.06);
			model.position.set(401.5, -0.35, 407);
			scene.add(gltf.scene);
		}, undefined, function (error) {
			console.error(error);
		});

		// c = (600, 600)
		loader.load('model/jar/scene.gltf', function (gltf) {
			model = gltf.scene.children[0];
			model.castShadow = true;
			model.receiveShadow = true;
			model.scale.set(0.06, 0.06, 0.06);
			model.position.set(601.5, -0.35, 607);
			scene.add(gltf.scene);
		}, undefined, function (error) {
			console.error(error);
		});

		// Tree.obj 객체 로드
		var loaderObj = new THREE.OBJLoader();

		// z = (200, 200)
		loaderObj.load('model/tree/Tree.obj', function (object) {
			object.traverse(function (child) {
				if (child.isMesh) {
					child.castShadow = true;
					child.receiveShadow = true;
					if (child.name === 'default1') {
						const texture = textureLoader.load('model/tree/bark_0021.jpg', (texture) => {
							child.material.map = texture;
							child.material.needsUpdate = true;
						});
					}
				}
			});
			object.scale.set(0.65, 0.65, 0.65);
			object.position.set(201.5, -0.35, 207);
			scene.add(object);
		});

		// x = (400, 400)
		loaderObj.load('model/tree/Tree.obj', function (object) {
			object.traverse(function (child) {
				if (child.isMesh) {
					child.castShadow = true;
					child.receiveShadow = true;
					if (child.name === 'default1') {
						const texture = textureLoader.load('model/tree/bark_0021.jpg', (texture) => {
							child.material.map = texture;
							child.material.needsUpdate = true;
						});
					}
				}
			});
			object.scale.set(0.65, 0.65, 0.65);
			object.position.set(401.5, -0.35, 407);
			scene.add(object);
		});

		// c = (600, 600)
		loaderObj.load('model/tree/Tree.obj', function (object) {
			object.traverse(function (child) {
				if (child.isMesh) {
					child.castShadow = true;
					child.receiveShadow = true;
					if (child.name === 'default1') {
						const texture = textureLoader.load('model/tree/bark_0021.jpg', (texture) => {
							child.material.map = texture;
							child.material.needsUpdate = true;
						});
					}
				}
			});
			object.scale.set(0.65, 0.65, 0.65);
			object.position.set(601.5, -0.35, 607);
			scene.add(object);
		});

		//});


		var teleportCount = 0; // z 키 눌림 횟수를 기록할 변수 추가

		function onKeyDown(event) {
			if (event.code == "Space" || event.keyCode == 32) {
				jumpT = t;
			}
			if (event.code == "ArrowLeft" || event.keyCode == 37) {
				turnLeft = true;
				turnRight = false;
			}
			if (event.code == "ArrowRight" || event.keyCode == 39) {
				turnLeft = false;
				turnRight = true;
			}
			if (event.code == "ArrowUp" || event.keyCode == 38) {
				goForward = true;
			}

			// z 키를 누를 때마다 위치 변경 (짝수 번 누르면 원점으로 돌아감)
			if (event.code == "KeyZ") {
				teleportCount++;

				if (teleportCount % 2 === 1) {
					// 홀수 번째 누름: 특정 위치로 텔레포트
					x = 200;
					z = 205.5;
				} else {
					// 짝수 번째 누름: 원점(시작점)으로 이동
					x = 1;
					z = 2;
				}
			}
			// x 키를 누를 때마다 위치 변경 (짝수 번 누르면 원점으로 돌아감)
			if (event.code == "KeyX") {
				teleportCount++;

				if (teleportCount % 2 === 1) {
					// 홀수 번째 누름: 특정 위치로 텔레포트
					x = 400;
					z = 405.5;
				} else {
					// 짝수 번째 누름: 원점(시작점)으로 이동
					x = 1;
					z = 2;
				}
			}

			// c 키를 누를 때마다 위치 변경 (짝수 번 누르면 원점으로 돌아감)
			if (event.code == "KeyC") {
				teleportCount++;

				if (teleportCount % 2 === 1) {
					// 홀수 번째 누름: 특정 위치로 텔레포트
					x = 600;
					z = 605.5;
				} else {
					// 짝수 번째 누름: 원점(시작점)으로 이동
					x = 1;
					z = 2;
				}
			}
		}



		function onKeyUp(event) {
			if (event.code == "ArrowLeft" || event.keyCode == 37) { turnLeft = false; }
			if (event.code == "ArrowRight" || event.keyCode == 39) { turnRight = false; }
			if (event.code == "ArrowUp" || event.keyCode == 38) { goForward = false; }
		}

		function canWalkTo(x, y) {
			for (var i = 0; i < 5; i++) {
				var nx = Math.round(x + 0.3 * Math.cos(dir + i / 5));
				var ny = Math.round(y + 0.3 * Math.sin(dir + i / 5));

				if (isWall(nx, ny)) { return false; }

				return true;
			}

		}

		var t = 0;
		var jumpT = -1000;

		function drawFrame() {

			if (turnLeft) { dir -= 0.02; }
			if (turnRight) { dir += 0.02; }
			cos = Math.cos(dir);
			sin = Math.sin(dir);

			if (goForward) {
				if (canWalkTo(x + 0.1 * cos, z + 0.1 * sin)) {
					x += 0.025 * cos;
					z += 0.025 * sin;
				} else if (canWalkTo(x - 0.1 * cos, z + 0.05 * sin)) {
					z += 0.025 * sin;
				} else if (canWalkTo(x + 0.05 * cos, z - 0.1 * sin)) {
					x += 0.025 * cos;
				}
			}

			// RESTART
			// goal detection and reset position to start (0,0)
			var distanceToGoal = Math.sqrt(Math.pow(goal.position.x - x, 2) + Math.pow(goal.position.z - z, 2));
			if (distanceToGoal < 0.5) {
				x = 1; // 시작 지점 X 좌표
				z = 2; // 시작 지점 Z 좌표
				dir = 0;
				goForward = false;
				turnLeft = false;
				turnRight = false;

				var cos = Math.cos(dir);
				var sin = Math.sin(dir);

				light.position.set(x, 0, z);
				light.target.position.set(x + cos, -0.1, z + sin);

				// 카메라 위치 업데이트
				var height = 0;
				if (t - jumpT < 450) {
					height = 2 + 2 * Math.cos((t - jumpT) / 450 * 2 * Math.PI - Math.PI);
				}

				camera.position.set(x - 0.1 * cos, 0 + height, z - 0.1 * sin);
				camera.lookAt(new THREE.Vector3(x + 10.4 * cos, 0.95 * height, z + 10.4 * sin));
				// generateLabyrinth(); 호출 제거

			}



			t++;

			light.position.set(x, 0, z);
			light.target.position.set(x + cos, -0.1, z + sin);

			var height = 0;
			if (t - jumpT < 450) {
				height = 2 + 2 * Math.cos((t - jumpT) / 450 * 2 * Math.PI - Math.PI);
			}


			camera.position.set(x - 0.1 * cos, 0 + height, z - 0.1 * sin);

			camera.lookAt(new THREE.Vector3(x + 10.4 * cos, 0.95 * height, z + 10.4 * sin));

			renderer.render(scene, camera);
		}
	</script>
</body>
</html>