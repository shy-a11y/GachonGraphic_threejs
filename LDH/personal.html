<html>
	<head>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="three.min.js"></script>
		<script src="labyrinth.js"></script>
		<script src="GLTFLoader.js"></script>
		<script src="OBJLoader.js"></script>
		<script src="MTLLoader.js" type="module"></script>

		<script>
			var renderer = new THREE.WebGLRenderer({antialias:true});
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setAnimationLoop( drawFrame );
			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.PCFSoftShadowMap;
			document.body.appendChild( renderer.domElement );
			
			document.body.addEventListener('keydown', onKeyDown);
			document.body.addEventListener('keyup', onKeyUp);

			var scene = new THREE.Scene();

			var aspect = window.innerWidth/window.innerHeight;
			var camera = new THREE.PerspectiveCamera( 30, aspect );
			camera.position.set( 30, 15, 30 );
			camera.lookAt( scene.position );
	
			var plane = new THREE.Mesh(new THREE.BoxGeometry(20, 0.1, 20), new THREE.MeshPhongMaterial({color:'gray'}));
			plane.position.set(0,-0.4,0);
			scene.add(plane);
			
			var goal = new THREE.Mesh(new THREE.SphereGeometry(1,32,32), new THREE.MeshPhongMaterial({color:'white'}));
			goal.position.set(2*dW-3,1.5,2*dH);
			scene.add(goal);

			generateLabyrinth();
			
		
			var block = new THREE.BoxGeometry( 1, 1, 1 ); 
			var labyrinth = new THREE.Group(); 
			var labyrinthMaterial = new THREE.MeshPhongMaterial( {color: 'gray', shininess: 10} );

			var border = new THREE.Group();
			var borderMaterial = new THREE.MeshPhongMaterial({color: 'brown'});


			for( var x=0; x<2*dW+1; x++ )
			for( var y=0; y<2*dH+2; y++ )
				if( isWall(x,y) )
				{
					
					var wall = new THREE.Mesh( block, labyrinthMaterial );
					var h = 0.4 + 1.2*Math.random();
					wall.scale.set(1,h,1);
					wall.position.set(x,h/2-0.5,y);
					labyrinth.add( wall );

					if (h<0.7) {
						var wall = wall.clone();
						wall.scale.set(1,0.2,1);
						wall.position.set(x,0.5,y);
						labyrinth.add(wall);
					}

					var wall = new THREE.Mesh(block, borderMaterial);
					wall.scale.set(1.05, 1, 1.05);
					wall.position.set(x, -0.8, y);
					border.add(wall);
				}
			scene.add( labyrinth, border );
		
			var x = 1;
			var z = 2;
			var dir = 0;

			var turnLeft = false;
			var turnRight = false;
			var goForward = false;

			var cos = Math.cos(dir);
			var sin = Math.sin(dir);

		


			// 개인 장소의 불빛
			light = new THREE.DirectionalLight("white", 1);  // 방향성 조명 추가
			light.position.set(200, 200, 200);  // 조명 위치 설정
			light.castShadow = true;
			light.target.position.set(0, -1, 0);
			scene.add(light.target);
			scene.add(light);

			var pointLight = new THREE.PointLight(0xffa500, 2, 10);  // 주황빛, 강도, 거리
			pointLight.position.set(196, 0.5, 213.5);
			pointLight.castShadow = true;
			scene.add(pointLight);

			var pointLight = new THREE.PointLight(0xffa500, 2, 10);  // 주황빛, 강도, 거리
			pointLight.position.set(196, 0.5, 204.5);
			pointLight.castShadow = true;
			scene.add(pointLight);
			
			var pointLight = new THREE.PointLight(0xffa500, 2, 10);  // 주황빛, 강도, 거리
			pointLight.position.set(204, 0.5, 204.5);
			pointLight.castShadow = true;
			scene.add(pointLight);

			var pointLight = new THREE.PointLight(0xffa500, 2, 10);  // 주황빛, 강도, 거리
			pointLight.position.set(204, 0.5, 213.5);
			pointLight.castShadow = true;
			scene.add(pointLight);

			//개인 공간 꾸미는 곳
			const textureLoader = new THREE.TextureLoader();
			const texture = textureLoader.load('model/sea/textures/material_4_baseColor.jpeg'); // 텍스처 파일 경로 지정

			// 구체 생성
			const sphereGeometry = new THREE.SphereGeometry(20, 32, 32); // 구체의 반지름을 10으로 설정
			const sphereMaterial = new THREE.MeshPhongMaterial({
    		map: texture,  // 텍스처를 구체 재질에 추가
			side: THREE.BackSide
			});

			// 텍스처가 적용된 구체 메시 생성
			const texturedSphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
			texturedSphere.position.set(202, 1, 208);  // 구체 위치 설정



			var plane = new THREE.Mesh(new THREE.BoxGeometry(10, 0.1, 10), new THREE.MeshPhongMaterial({color:'gray'}));
			plane.position.set(200.5,-0.4,209.5);
			plane.castShadow = true;
			plane.receiveShadow = true;
			scene.add(plane);

			var plane = new THREE.Mesh(new THREE.BoxGeometry(10, 1, 0.1), new THREE.MeshPhongMaterial({color:'gray'}));
			plane.position.set(200.5,-0.4,204.5);
			plane.receiveShadow = true;
			plane.castShadow = true;
			scene.add(plane);

			var plane = new THREE.Mesh(new THREE.BoxGeometry(10, 1, 0.1), new THREE.MeshPhongMaterial({color:'gray'}));
			plane.position.set(200.5,-0.4,214.5);
			plane.receiveShadow = true;
			plane.castShadow = true;
			scene.add(plane);

			var plane = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1, 10), new THREE.MeshPhongMaterial({color:'gray'}));
			plane.position.set(205.5,-0.4,209.5);
			plane.receiveShadow = true;
			plane.castShadow = true;
			scene.add(plane);

			var plane = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1, 10), new THREE.MeshPhongMaterial({color:'gray'}));
			plane.position.set(195.5,-0.4,209.5);
			plane.receiveShadow = true;
			plane.castShadow = true;
			scene.add(plane);

			// GLTF 파일 로드
			const loader = new THREE.GLTFLoader();
			loader.load('model/jar/scene.gltf', function(gltf){
	  		model = gltf.scene.children[0];
			model.castShadow = true;        // 모델이 그림자를 투사하도록 설정
			model.receiveShadow = true;  
			model.scale.set(0.06,0.06,0.06);

			model.position.x = 205;
			model.position.y = 0;
			model.position.z = 214.5;
	  		scene.add(gltf.scene);
			}, undefined, function (error) {
			console.error(error);
			});


			loader.load('model/jar/scene.gltf', function(gltf){
	  		model = gltf.scene.children[0];
			model.castShadow = true;        // 모델이 그림자를 투사하도록 설정
			model.receiveShadow = true;  
			model.scale.set(0.06,0.06,0.06);

			model.position.x = 201.5;
			model.position.y = -0.35;
			model.position.z = 207;
	  		scene.add(gltf.scene);
			}, undefined, function (error) {
			console.error(error);
			});

			//const mtlLoader = new THREE.MTLLoader();
    		//mtlLoader.load('model/tree/Tree.mtl', function (materials) {
        	//materials.preload(); // 재질을 미리 로드

			var loaderObj = new THREE.OBJLoader();
			//objLoader.setMaterials(materials); // OBJ 로더에 재질 설정
    		loaderObj.load(
        	'model/tree/Tree.obj', // OBJ 파일 경로
       		 function (object) {
            //모델에 그림자를 투사하고 수신하도록 설정
            object.traverse(function (child) {
                if (child.isMesh) {
                    child.castShadow = true;   // 그림자를 투사
                    child.receiveShadow = true; // 그림자를 수신

					if (child.name === 'default1') {
                const texture = textureLoader.load('model/tree/bark_0021.jpg', (texture) => {
                    child.material.map = texture;
                    child.material.needsUpdate = true;
                });
            }
                }
            });
			
			object.scale.set(0.65,0.65,0.65);

			object.position.x = 201.5;
			object.position.y = -0.35;
			object.position.z = 207;
            scene.add(object); // 씬에 추가
		});
	//});
			

			function onKeyDown(event) {
				if(event.code=="Space" || event.keyCode ==32) {jumpT = t;}
				if(event.code=="ArrowLeft" || event.keyCode ==37) {turnLeft=true; turnRight=false;}
				if(event.code=="ArrowRight" || event.keyCode ==39) {turnLeft=false; turnRight=true;}
				if(event.code=="ArrowUp" || event.keyCode ==38) {goForward=true;}

				//임시로 z를 누르면 텔포
				if(event.code=="KeyZ") {x = 200; z = 205.5; }
			}		
			

			function onKeyUp(event) {
				if(event.code=="ArrowLeft" || event.keyCode ==37) {turnLeft=false;}
				if(event.code=="ArrowRight" || event.keyCode ==39) {turnRight=false;}
				if(event.code=="ArrowUp" || event.keyCode ==38) {goForward=false;}
			}

			function canWalkTo(x,y) {
				for (var i=0; i<5; i++) {
					var nx = Math.round(x+0.3*Math.cos(dir+i/5));
					var ny = Math.round(y+0.3*Math.sin(dir+i/5));
					
					if(isWall(nx, ny)) {return false; }

					return true;
				}

			}

			var t = 0;
			var jumpT = -1000;
		
			function drawFrame()
			{

				if(turnLeft) {dir-=0.02;}
				if(turnRight) {dir+=0.02;}
				cos=Math.cos(dir);
				sin=Math.sin(dir);

				if(goForward) {
					if(canWalkTo(x+0.1*cos, z+0.1*sin)) {
						x+=0.025*cos;
						z+=0.025*sin;
					} else if (canWalkTo(x-0.1*cos, z+0.05*sin)) {
						z+=0.025*sin;
					} else if (canWalkTo(x+0.05*cos, z-0.1*sin)) {
						x+=0.025*cos;
					}
				}

				t++;

				light.position.set(x,0,z);
				light.target.position.set(x+cos, -0.1, z+sin);

				var height = 0;
				if (t-jumpT<450) {
					height=2+2*Math.cos((t-jumpT)/450 * 2*Math.PI-Math.PI);
				}


        		camera.position.set(x - 0.1 * cos, 0 + height, z - 0.1 * sin);

				camera.lookAt(new THREE.Vector3(x+10.4*cos, 0.95*height, z+10.4*sin));

				renderer.render( scene, camera );
			}
		</script>
	</body>
</html>