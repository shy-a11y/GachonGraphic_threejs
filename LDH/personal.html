<html>
	<head>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="three.min.js"></script>
		<script src="labyrinth.js"></script>
		<script src="OBJLoader.js"></script>

		<script>
			var renderer = new THREE.WebGLRenderer({antialias:true});
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setAnimationLoop( drawFrame );
			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.PCFSoftShadowMap;
			document.body.appendChild( renderer.domElement );
			
			document.body.addEventListener('keydown', onKeyDown);
			document.body.addEventListener('keyup', onKeyUp);

			var scene = new THREE.Scene();

			var aspect = window.innerWidth/window.innerHeight;
			var camera = new THREE.PerspectiveCamera( 30, aspect );
			camera.position.set( 30, 15, 30 );
			camera.lookAt( scene.position );
	
			var plane = new THREE.Mesh(new THREE.BoxGeometry(20, 0.1, 20), new THREE.MeshPhongMaterial({color:'gray'}));
			plane.position.set(0,-0.4,0);
			scene.add(plane);
			
			var goal = new THREE.Mesh(new THREE.SphereGeometry(1,32,32), new THREE.MeshPhongMaterial({color:'white'}));
			goal.position.set(2*dW-3,1.5,2*dH);
			scene.add(goal);

			generateLabyrinth();
			
		
			var block = new THREE.BoxGeometry( 1, 1, 1 ); 
			var labyrinth = new THREE.Group(); 
			var labyrinthMaterial = new THREE.MeshPhongMaterial( {color: 'gray', shininess: 10} );

			var border = new THREE.Group();
			var borderMaterial = new THREE.MeshPhongMaterial({color: 'brown'});


			for( var x=0; x<2*dW+1; x++ )
			for( var y=0; y<2*dH+2; y++ )
				if( isWall(x,y) )
				{
					
					var wall = new THREE.Mesh( block, labyrinthMaterial );
					var h = 0.4 + 1.2*Math.random();
					wall.scale.set(1,h,1);
					wall.position.set(x,h/2-0.5,y);
					labyrinth.add( wall );

					if (h<0.7) {
						var wall = wall.clone();
						wall.scale.set(1,0.2,1);
						wall.position.set(x,0.5,y);
						labyrinth.add(wall);
					}

					var wall = new THREE.Mesh(block, borderMaterial);
					wall.scale.set(1.05, 1, 1.05);
					wall.position.set(x, -0.8, y);
					border.add(wall);
				}
			scene.add( labyrinth, border );
		
			var x = 1;
			var z = 2;
			var dir = 0;

			var turnLeft = false;
			var turnRight = false;
			var goForward = false;

			var cos = Math.cos(dir);
			var sin = Math.sin(dir);

		


			// 개인 장소의 불빛
			light = new THREE.DirectionalLight("white", 1);  // 방향성 조명 추가
			light.position.set(200, 200, 200);  // 조명 위치 설정
			light.castShadow = true;
			light.target.position.set(0, -1, 0);
			scene.add(light.target);
			scene.add(light);

			var pointLight = new THREE.PointLight(0xffa500, 2, 4);  // 주황빛, 강도, 거리
			pointLight.position.set(201.2, 0.5, 209.5);
			pointLight.castShadow = true;
			scene.add(pointLight);

	

			//개인 공간 꾸미는 곳
			var textureLoader = new THREE.TextureLoader();
			var texture;

			// 구체 생성
			var sphereGeometry = new THREE.SphereGeometry(20, 32, 32); // 구체의 반지름을 10으로 설정
			var sphereMaterial = new THREE.MeshPhongMaterial({
    		map: texture,  // 텍스처를 구체 재질에 추가
			side: THREE.BackSide
			});

			// 텍스처가 적용된 구체 메시 생성
			const texturedSphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
			texturedSphere.position.set(202, 1, 208);  // 구체 위치 설정


			var texture = new THREE.TextureLoader().load('model/wall.jpg');

			texture.wrapS = THREE.RepeatWrapping;
			texture.wrapT = THREE.RepeatWrapping;
			texture.repeat.set(10, 10);

			var texture3 = new THREE.TextureLoader().load('model/wall.jpg');

			texture3.wrapS = THREE.RepeatWrapping;
			texture3.wrapT = THREE.RepeatWrapping;
			texture3.repeat.set(10, 10);


			var plane = new THREE.Mesh(new THREE.BoxGeometry(10, 0.1, 10), new THREE.MeshPhongMaterial({map:texture3}));
			plane.position.set(200.5,-0.4,209.5);
			plane.castShadow = true;
			plane.receiveShadow = true;
			scene.add(plane);

			texture.repeat.set(10, 1);

			var plane = new THREE.Mesh(new THREE.BoxGeometry(10, 1, 0.1), new THREE.MeshPhongMaterial({map:texture}));
			plane.position.set(200.5,-0.4,204.5);
			plane.receiveShadow = true;
			plane.castShadow = true;
			scene.add(plane);

			var plane = new THREE.Mesh(new THREE.BoxGeometry(10, 1, 0.1), new THREE.MeshPhongMaterial({map:texture}));
			plane.position.set(200.5,-0.4,214.5);
			plane.receiveShadow = true;
			plane.castShadow = true;
			scene.add(plane);

			var plane = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1, 10), new THREE.MeshPhongMaterial({map:texture}));
			plane.position.set(205.5,-0.4,209.5);
			plane.receiveShadow = true;
			plane.castShadow = true;
			scene.add(plane);

			var plane = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1, 10), new THREE.MeshPhongMaterial({map:texture}));
			plane.position.set(195.5,-0.4,209.5);
			plane.receiveShadow = true;
			plane.castShadow = true;
			scene.add(plane);

// 텍스처 로더 생성
			const textureLoader2 = new THREE.TextureLoader();
			const texture2 = textureLoader2.load('model/bg.jpg'); // 텍스처 파일 경로 지정

// 큰 구체 생성 (배경용)
const sphereGeometry2 = new THREE.SphereGeometry(20, 64, 64); // 큰 구체를 만들어 내부가 배경처럼 보이게 설정
const sphereMaterial2 = new THREE.MeshBasicMaterial({
    map: texture2,       // 텍스처를 재질에 추가
    side: THREE.BackSide // 구체의 안쪽 면을 렌더링하도록 설정
});

// 텍스처가 적용된 구체 메시 생성
const backgroundSphere = new THREE.Mesh(sphereGeometry2, sphereMaterial2);
backgroundSphere.position.set(200, 0, 200); // 구체를 씬의 중심에 위치시켜 전체를 감싸도록 설정
scene.add(backgroundSphere);

			var loaderObj = new THREE.OBJLoader();
    		loaderObj.load(
        	'model/tree/Tree.obj', // OBJ 파일 경로
       		 function (object) {
            object.traverse(function (child) {
                if (child.isMesh) {
                    child.castShadow = true;   // 그림자를 투사
                    child.receiveShadow = true; // 그림자를 수신

					if (child.name === 'Tree_polySurface1 g1 polySurface1') {
                	var barkTexture = textureLoader.load('model/tree/bark_0021.jpg');
                	child.material = new THREE.MeshStandardMaterial({ map: barkTexture });
                	child.material.needsUpdate = true;

            		} else if (child.name === 'Tree_polySurface1 g1 g2 polySurface1') {
                	var leafTexture = textureLoader.load('model/tree/DB2X2_L01.png');
                	child.material = new THREE.MeshStandardMaterial({ map: leafTexture });
                	child.material.needsUpdate = true;
            }
    			};
            });

			object.scale.set(0.65,0.65,0.65);
			object.position.x = 202.5;
			object.position.y = -0.35;
			object.position.z = 210;
            scene.add(object); // 씬에 추가
		});
			
		loaderObj.load(
        	'model/tree/Tree.obj', // OBJ 파일 경로
       		 function (object) {
            object.traverse(function (child) {
                if (child.isMesh) {
                    child.castShadow = true;   // 그림자를 투사
                    child.receiveShadow = true; // 그림자를 수신

					if (child.name === 'Tree_polySurface1 g1 polySurface1') {
                	const barkTexture = textureLoader.load('model/tree/bark_0021.jpg');
                	child.material = new THREE.MeshStandardMaterial({ map: barkTexture });
                	child.material.needsUpdate = true;

            		} else if (child.name === 'Tree_polySurface1 g1 g2 polySurface1') {
                	const leafTexture = textureLoader.load('model/tree/DB2X2_L01.png');
                	child.material = new THREE.MeshStandardMaterial({ map: leafTexture });
                	child.material.needsUpdate = true;
            }
    			};
            });

			object.scale.set(0.65,0.65,0.65);
			object.position.x = 200.5;
			object.position.y = -0.35;
			object.position.z = 210;
            scene.add(object); // 씬에 추가
		});


		loaderObj.load(
        	'model/fire/Campfire.obj', // OBJ 파일 경로
       		 function (object) {
            object.traverse(function (child) {
                if (child.isMesh) {
                    child.castShadow = true;   // 그림자를 투사
                    child.receiveShadow = true; // 그림자를 수신

					if (child.name === 'Campfire') {
                	const CampfireTexture = textureLoader.load('model/fire/Textures/HD/Campfire_MAT_BaseColor_01.jpg');
                	child.material = new THREE.MeshStandardMaterial({ map: CampfireTexture });
                	child.material.needsUpdate = true;
					}

            }
            });

			object.scale.set(0.0065,0.0065,0.0065);
			object.position.x = 201.2;
			object.position.y = -0.34;
			object.position.z = 209.5;
            scene.add(object); // 씬에 추가
		});


		loaderObj.load(
        	'model/fire/flame.obj', // OBJ 파일 경로
       		 function (object) {
            object.traverse(function (child) {
                if (child.isMesh) {
                    child.castShadow = true;   // 그림자를 투사
                    child.receiveShadow = true; // 그림자를 수
					
					child.material.color.set(0xffa500);
            }
            });

			object.scale.set(0.1,0.1,0.1);
			object.position.x = 201.2;
			object.position.y = -0.4;
			object.position.z = 209.5;
            scene.add(object); // 씬에 추가
		});



			function onKeyDown(event) {
				if(event.code=="Space" || event.keyCode ==32) {jumpT = t;}
				if(event.code=="ArrowLeft" || event.keyCode ==37) {turnLeft=true; turnRight=false;}
				if(event.code=="ArrowRight" || event.keyCode ==39) {turnLeft=false; turnRight=true;}
				if(event.code=="ArrowUp" || event.keyCode ==38) {goForward=true;}

				//임시로 z를 누르면 텔포
				if(event.code=="KeyZ") {x = 200; z = 205.5; }
			}		
			

			function onKeyUp(event) {
				if(event.code=="ArrowLeft" || event.keyCode ==37) {turnLeft=false;}
				if(event.code=="ArrowRight" || event.keyCode ==39) {turnRight=false;}
				if(event.code=="ArrowUp" || event.keyCode ==38) {goForward=false;}
			}

			function canWalkTo(x,y) {
				for (var i=0; i<5; i++) {
					var nx = Math.round(x+0.3*Math.cos(dir+i/5));
					var ny = Math.round(y+0.3*Math.sin(dir+i/5));
					
					if(isWall(nx, ny)) {return false; }

					return true;
				}

			}

			var t = 0;
			var jumpT = -1000;
		
			function drawFrame()
			{

				if(turnLeft) {dir-=0.02;}
				if(turnRight) {dir+=0.02;}
				cos=Math.cos(dir);
				sin=Math.sin(dir);

				if(goForward) {
					if(canWalkTo(x+0.1*cos, z+0.1*sin)) {
						x+=0.025*cos;
						z+=0.025*sin;
					} else if (canWalkTo(x-0.1*cos, z+0.05*sin)) {
						z+=0.025*sin;
					} else if (canWalkTo(x+0.05*cos, z-0.1*sin)) {
						x+=0.025*cos;
					}
				}

				t++;

				light.position.set(x,0,z);
				light.target.position.set(x+cos, -0.1, z+sin);

				var height = 0;
				if (t-jumpT<450) {
					height=2+2*Math.cos((t-jumpT)/450 * 2*Math.PI-Math.PI);
				}


        		camera.position.set(x - 0.1 * cos, 0 + height, z - 0.1 * sin);

				camera.lookAt(new THREE.Vector3(x+10.4*cos, 0.95*height, z+10.4*sin));

				renderer.render( scene, camera );
			}
		</script>
	</body>
</html>